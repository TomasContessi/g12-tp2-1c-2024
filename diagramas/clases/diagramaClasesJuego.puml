@startuml

skinparam monochrome true
hide circle
skinparam classAttributeIconSize 0

class JsonLoader {
    - filePath:String
    - totalPreguntas:int
    - respuestaCorrecta:Respuesta
    - textoRespuesta:String
    + JsonLoader(filePath:String)
    + leerAtributos(id:int):JsonObject
    + loadPregunta(id:int):Pregunta
    + respuestaCorrecta():Respuesta
    + opciones():ArrayList<Opcion>
    + totalPreguntas():int
}

class DiccionarioPreguntas {
    + asignarPreguntasPorTema(jsonLoader:JsonLoader)
    + getPregunta():Pregunta
    + ultimaPregunta():boolean
}

class PreguntaFactory {
    + crearPregunta(datosEnunciado:JsonObject, respuestaCorrecta:Respuesta, opciones:ArrayList<Opcion>):Pregunta
}

class RecorredorPreguntas {
    - indiceActualPorClave:Map<String, Integer>
    - clavesOrdenadas:ArrayList<String>
    - indiceGlobal:int
    - indiceActual:int
    + RecorredorPreguntas(preguntasGuardadas:Map<String, ArrayList<Pregunta>>)
    + obtenerPregunta():Pregunta
    + ultimaPregunta():boolean
}

class Jugador {
    - nombre:String
    - respuesta:Respuesta
    + Jugador(nombre:String)
    + cambiarRespuesta()
    + agregarOpcion(pregunta:Pregunta, numeroOpcion:int)
    + usarMultiplicador(pregunta:Pregunta, multiplicador:Multiplicador)
    + getNombre():String
    + getRespuesta():Respuesta
    + asignarPuntos(puntos:Puntaje)
    + getPuntos():Puntaje
}

class Juego {
    - jugadorActual: int
    + agregarJugador(jugador: Jugador)
    + listaJugadoresVacia():boolean
    + verificarArrayJugadores()
    + setearPreguntas()
    + obtenerPregunta():Pregunta
    + getJugadorActual():Jugador
    + ultimoJugador():boolean
    + reiniciarJugadorActual()
    + agregarPuntaje(jugador:Jugador, puntaje:Puntaje)
    + verificarRespuestaJugador(jugador:Jugador, pregunta:Pregunta)
    + asignarPuntajeJugadores()
    + iterableJugadorPuntajes():Iterable<Map.Entry<Jugador, Puntaje>
    + resetearRespuestasJugadores()
    + ultimaPregunta():boolean
}

class Puntaje {
    - valor:int
    + Puntaje(puntaje:int)
    + multiplicarseCon(otroPuntaje:Puntaje):Puntaje
    + sumarseCon(otroPuntaje:Puntaje):Puntaje
    + valorNumerico():int 
    + equals(Object o):boolean
    + hashCode():int
}

abstract class Pregunta {
    - tipo:Tipo
    - tema:String
    - tipoPregunta:String
    - enunciado:String
    - respuestaCorrecta:Respuesta
    - multiplicador:Multiplicador
    - textoRespuesta:String
    - numeroOpcion:int
    + Pregunta(tipo:Tipo, respuestaCorrecta:Respuesta)
    + Pregunta(tipo:Tipo, respuestaCorrecta:Respuesta, enunciado:String, tipoPregunta:String, opciones:ArrayList<Opcion>, tema:String, textoRespuesta:String)
    + setMultiplicador(Multiplicador multiplicador)
    + mostrarOpcion():Opcion
    + setearRespuestaJugador(respuestaJugador:Respuesta, numeroOpcion:int)
    + getEnunciado():String
    + getTema():String
    + getTipoPregunta():String
    + getTextoRespuesta():String
    + getRespuestaCorrecta():Respuesta
    + tienePenalidad():boolean
    + verificarRespuesta(respuestaJugador:Respuesta):Puntaje
}

class Opcion {
    - valor:String
    + Opcion(valor:String)
    + equals(o:Object):boolean
    + hashCode():int
    + obtenerValor():String
}

DiccionarioPreguntas ..>  JsonLoader

JsonLoader *-- PreguntaFactory
DiccionarioPreguntas *-left- RecorredorPreguntas

Juego o-right- "1..*" Jugador
Juego -left-> DiccionarioPreguntas
Juego o-- "1..*" Puntaje
DiccionarioPreguntas o-down- "1..*" Pregunta
RecorredorPreguntas o-down- "1..*" Pregunta
PreguntaFactory .down.> Pregunta

JsonLoader o-left- "1..*" Opcion
Jugador -up-> Puntaje
Pregunta .right.> Puntaje
Jugador .down.> Pregunta
Pregunta o-left- "*" Opcion
Juego *-- JsonLoader

@enduml
